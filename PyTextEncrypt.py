import sys

"""
PyTextEncrypt

A number of simple algorithms which will encrypt plain text. 

Author: 
Andrew Mummery, 
Oxford University Astrophysics,
andrew.mummery2@ntlworld.com 

"""

"""
The main mathematics behind the ciphers are governed by the properties
of the binary representations of integers and the XOR operation [+]. 
The binary representations of integers form a Group with operation [+]. 

Binary representation: 
Take two integers A and B

A = A_0 A_1 A_2 A_3 ...
B = B_0 B_1 B_2 B_3 ...

where A_i, B_i = {0, 1}, binary digits. 

The XOR operator is defined as acting on each digit 

A [+] B = (A_0 [+] B_0) (A_1 [+] B_1) (A_2 [+] B_2) ...

where: 

0 [+] 0 = 0
0 [+] 1 = 1             This is equivalent to 
1 [+] 0 = 1             X [+] Y = X + Y (mod 2).
1 [+] 1 = 0

Most of the ciphers fundamentally boil down to taking a plaintext 
P, converting it to a binary string, and then XORing that binary 
string with a 'key string' K, derived from a user-defined password. 
The result is a 'ciphertext' binary string C:
C = P [+] K.

which can then be converted back to alpha-numeric characters, the 
encrypted text. 

Note that this Group has an identity element, I = 00000000, which satisfies
A [+] I = A, and each element is its own inverse under the XOR operation:
A [+] A = I.  This means that for simple symmetric encryptions the same key
encrypts and decrypts the plaintext: 
C = P [+] K 
P = P [+] I = P [+] K [+] K = C [+] K

"""


def printProgressBar(Q,max,preText):
    n_bar =30 #size of progress bar
    q = Q/max
    sys.stdout.write('\r')
    sys.stdout.write(f" {preText} [{'=' * int(n_bar * q):{n_bar}s}] ")
    sys.stdout.flush()

def key(pin,length_message):
    """
    This function creates a binary key-stream of length "length_message" from an input
    integer pin "pin". 
    
    This pin is first represented by a binary string of length n0.
    
    The key stream is generated by XORing the jth and (j+n0-1)th binary digits of the 
    key stream together to get the (j+n0)th binary digit of the key. This continues until
    the key stream is the same length as "length_message". 
    
    A key stream generated in this manner repeats after 2^n0 - 1 binary digits. 
    
    The idea behind this method is taken from page 65 of AVSI: Cryptography, Piper & Murphy
    """
    k = bin(pin)[2:]
    j=0
    n0 = len(k)
    while j < length_message-n0:
        s1 = int(k[j])
        s2 = int(k[j+n0-1])
        p = s1 ^ s2# XOR operation. 
        k=k+str(p)
        j+=1
        if (100*(j+1)) % round(length_message-n0,-1) == 0:
            printProgressBar(j+1,length_message-n0,"Key generation:")
    printProgressBar(j+1,length_message-n0,"Key generation:")    
    print()
    return k

def key2(password,length_message):
    """
    This function creates a binary key-stream of length "length_message" from an input
    alpha-numerical password "password". 
    
    This password is first transformed into a binary string of length n0. This transformation
    uses the 'library()' function which maps alpha-numeric strings to binary representations. 
    
    The key stream is then generated by XORing the jth and (j+n0-1)th binary digits of the 
    key stream together to get the (j+n0)th binary digit of the key. This continues until
    the key stream is the same length as "length_message". 
    
    A key stream generated in this manner repeats after 2^n0 - 1 binary digits. 
    
    The idea behind this method is taken from page 65 of AVSI: Cryptography, Piper & Murphy
    """
    # lib, nib = library()
    k = message_to_binary(password)
    j=0
    n0 = len(k)
    while j < length_message-n0:
        s1 = int(k[j])
        s2 = int(k[j+n0-1])
        p = s1 ^ s2
        k=k+str(p)
        j+=1
        if (100*(j+1)) % round(length_message-n0,-1) == 0:
            printProgressBar(j+1,length_message-n0,"Key generation:")
    printProgressBar(j+1,length_message-n0,"Key generation:")    
    print()
    return k
    
def library():
    """
    Returns the 'library' and 'numbrary' used for mapping between alpha-numeric characters 
    and binary representations of length 7. There are a total of 128 alpha-numeric characters 
    which can be used in the (encrypted/plaintext) messages. Each character in the library 
    has a corresponding integer in the 'numbrary', and so can be represented by a unique 
    binary string of length 7. 
    
    i.e. 
    a -> 0 = 0000000
    ! -> 39 = 0100111
    
    The integer to binary mapping is done in the encryption loops.
    
    IMPORTANT NOTE: If an alpha-numeric character is not in the library then it cannot be
    encrypted and will be lost during the encryption/decryption process. 
    """
    alphabet = ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z']
    numberbet = ['0','1','2','3','4','5','6','7','8','9']
    punctuation = ['.',',','!','?',':',';','=','+','-','(',')','"','£','%','$','^','&',' ','/','[',']','*','@','_','<','>',"'"]
    Alphabet = ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z']
    misc = ['œ','∑','®','†','¥','|','`','π','å','ß','∂','ƒ','©','´','∆','˚','¬','Ω','≈','ç','√','∫','~','µ','≤','≥','÷','≠','€','#','∞','§','•','\n','Ø','Æ','Ÿ','∏','◊']
    lib = alphabet + numberbet + punctuation + Alphabet + misc
    nib = []
    for j in range(len(lib)):
        nib.append(j)
    return lib, nib
    
def message_to_binary(message):
    """
    Takes a message in plaintext and converts into a binary string. 
    Each character in the message, if its is in the library, is converted
    to the corresponding integer in the numbrary. This integer is then
    represented as a 7 digit binary string. 
    """
    lib, nib = library()
    binary_message = str()
    i, n_char = 0, len(message)
    for char in message:
        j = 0
        for let in lib:
            if char == let:
                binary_message += bin(nib[j])[2:].zfill(7)# pads with zeros to ensure 7 digits long.
            j+=1
        i+=1
        if ((i+1)*100) % round(n_char,-1) == 0:
            printProgressBar(i+1,n_char,"Alpha-numeric -> binary:")
    printProgressBar(i+1,n_char,"Alpha-numeric -> binary:")
    print()
    return binary_message

def binary_to_message(binary_message):
    """
    Takes a binary string and converts into a alpha-numeric text message.
    In effect the opposite of the function message_to_binary().
    The binary string is split into 7 digit sub-strings. These sub-strings
    are represented by an integer, and then replaced by the character in 
    the library with the equivalent numbrary integer. 
    """
    lib, nib = library()
    text_message = str()
    le = len(binary_message)
    if le % 7 != 0:
        print('WARNING: BINARY MESSAGE WRONG LENGTH.')
    else:
        n_char = int(le/7)
        for j in range(n_char):
            bin_char = binary_message[7*j:7*(j+1)]
            int_char = int(bin_char, 2)
            i = 0
            for num in nib:
                if num == int_char:
                    text_message += lib[i]
                i+=1
            if (100*(j+1)) % round(n_char,-1) == 0:
                printProgressBar(j+1,n_char,"Binary -> alpha-numeric:")
    printProgressBar(j+1,n_char,"Binary -> alpha-numeric:")
    print()
    return text_message

def encrypt_binary_stream_cipher(message_in_binary, key_string):
    """
    Takes a single key stream of the same length as the message, 
    then computes an encrypted binary stream by XORing the two 
    together. 
    
    Key stream should be computed by the function key, or key2. 
    """
    encrypted_binary = str()
    if len(message_in_binary) != len(key_string):
        print('The key provided is a different length to the message.')
    else:
        le = len(message_in_binary)
        if le % 7 != 0:
            print('WARNING: BINARY MESSAGE WRONG LENGTH.')
        else:
            bin_num = int(message_in_binary, 2)
            key_num = int(key_string, 2)
            mes_num = bin_num ^ key_num 
            encrypted_binary = bin(mes_num)[2:].zfill(le)
    return encrypted_binary

def decrypt_binary_stream_cipher(message_in_binary, key_string):
    """
    The stream cipher is perfectly symmetric, and so encryption and
    decryption are the same. Just given a name for ease of reading. 
    """
    decrypted_binary = encrypt_binary_stream_cipher(message_in_binary, key_string)
    return decrypted_binary

def encrypt_binary_cipher_block_chaining(message_in_binary, key_string):
    """
    This is a more sophisticated approach to encrypting a binary string.
    This method is based off of the method described on page 90 of 
    AVSI: Cryptography, Piper & Murphy.
    
    In this cipher the encryption of a character depends both on the key_stream
    but also on its location within the text. For particularly simple keys 
    (i.e a single letter key) this prevents the code from being susceptible to 
    attacks based on the structure of the english language. It does this by
    flattening the character-frequency distribution in the encrypted text. 
    
    Schematically the encryption process is the following.
    
    (Arrows in flow diagram should be followed in intuitive fashion.)
    
    [+] = binary XOR operation.
    
    INPUT:   p_1                     p_2
              |                       |
              v                       v
              |                       |
       iv ->-[+]            ---->----[+]                 --- > ......
              |             |         |                  |
             i_1            |        i_2                 |
              |             |         |                  |
              v             |         v                  |
              |             ^         |                  ^
    KEY:     [+]--<-- k_1   |        [+]--<-- k_2        |
              |             |         |                  |
              v             |         v                  |
              |             |         |                  |
             c_1------>-----|        c_2-------->--------|
              |                       |
              |                       |
    OUTPUT:   •                       •
    
    1. We split the input binary string and key into blocks of length 7
    
    MESSAGE -> p_1, p_2, p_3, ....
    
    KEY -> k_1, k_2, k_2, ....
    
    2. For the very first plaintext string, we XOR it with an
    'initial value' string, here hardcoded as 0101010. This produces
    an intermediate string i_1. 
    
    4. The ciphertext is then found by XORing this intermediate string 
    with the key stream. 
    
    5. For all other pieces of the plaintext we XOR the previous ciphertext
    c_{j-1} with the current plaintext p_{j} to form the intermediate string
    i_{j}, which is then encrypted with key string k_{j} using the XOR operation. 
    
    As is clear to see (below), c_{j} depends both on the key, the initial value iv,
    and all previous p_{i<j}
    
    c_{j} = i_{j} [+] k_{j} = (c_{j-1} [+] p_{j}) [+] k_{j} 
          = ((i_{j-1} [+] k_{j-1}) [+] p_{j}) [+] k_{j}
          = (((c_{j-2} [+] p_{j-1}) [+] k_{j-1}) [+] p_{j}) [+] k_{j}
          = .....
    """
    encrypted_binary = str()
    iv = '0101010'
    iv = int(iv,2)
    istr = str()
    if len(message_in_binary) != len(key_string):
        print('The key provided is a different length to the message.')
    else:
        le = len(message_in_binary)
        if le % 7 != 0:
            print('WARNING: BINARY MESSAGE WRONG LENGTH.')
        else:
            n_char = int(le/7)
            for j in range(n_char):
                p_char = int(message_in_binary[7*j:7*(j+1)], 2)
                key_char = int(key_string[7*j:7*(j+1)], 2)
                if j == 0:
                    ichar = iv ^ p_char
                    istr += bin(ichar)[2:].zfill(7)
                else:
                    c_min = int(encrypted_binary[7*(j-1):7*j], 2)
                    ichar = c_min ^ p_char
                    istr += bin(ichar)[2:].zfill(7)
                echar = key_char ^ int(istr[7*j:7*(j+1)],2)
                estr = bin(echar)[2:].zfill(7)
                encrypted_binary += estr
                if (100*(j+1)) % round(n_char,-1) == 0:
                    printProgressBar(j+1,n_char,"Encrypting: ")
    printProgressBar(j+1,n_char,"Encrypting: ")
    print()
    return encrypted_binary

def decrypt_binary_cipher_block_chaining(message_in_binary, key_string, line_breaks=True):
    """
    This function inverts the 'cipher block chaining' encryption algorithm.
    The encryption algorithm is described above. 
    
    As this is an inversion of the above program, it has a slightly 
    different structure. This structure is described schematically below:
    
    (Arrows in flow diagram should be followed in intuitive fashion.)
    
    [+] = binary XOR operation.
    
    INPUT:   c_1 ----->-----|        c_2 ------->------| 
              |             |         |                |
              v             |         v                |
              |             |         |                |
    KEY:     [+] --<-- k_1  |        [+] --<-- k_2     |             
              |             v         |                v
             i_1            |        i_2               |
              |             |         |                |
              v             |         v                |
              |             |         |                |
      iv ----[+]            ----->---[+]               --->---  ......
              |                       |                  
              |                       |                  
             p_1                     p_2
              |                       |
              |                       |
    OUTPUT:   •                       •
    
    """
    decrypted_binary = str()
    iv = '0101010'# I must be the same as the encryption algorithm or I will fail. 
    iv = int(iv,2)
    istr = str()
    if len(message_in_binary) != len(key_string):
        print('The key provided is a different length to the message.')
    else:
        le = len(message_in_binary)
        if le % 7 != 0:
            print('WARNING: BINARY MESSAGE WRONG LENGTH.')
        else:
            n_char = int(le/7)
            for j in range(n_char):
                c_char = int(message_in_binary[7*j:7*(j+1)], 2)
                key_char = int(key_string[7*j:7*(j+1)], 2)
                i_char = c_char ^ key_char
                istr += bin(i_char)[2:].zfill(7)
                if j == 0:
                    p_char = iv ^ i_char
                    p_str = bin(p_char)[2:].zfill(7)
                else:
                    i_min = int(message_in_binary[7*(j-1):7*j], 2)
                    p_char = i_min ^ i_char
                    p_str = bin(p_char)[2:].zfill(7)
                decrypted_binary += p_str
                if (100*(j+1)) % round(n_char,-1) == 0:
                    printProgressBar(j+1,n_char,"Decrypting:")
    printProgressBar(j+1,n_char,"Decrypting:")
    print()
    return decrypted_binary


def file_to_message(file_name='encrypt_me.txt'):
    message = str()
    with open(file_name) as fp:
        for line in fp:
            message += line
    return message

def message_to_file(message,save_name='encrypted_file.txt'):
    sf = open(save_name,'w+')
    sf.write(message)
    sf.close()

def encrypt_file(load_file_path=None, save_file_path=None, pin=None,algorithm='CBC'):
    if load_file_path != None:
        mes = file_to_message(load_file_path)
        bm = message_to_binary(mes)
    else:
        print()
        load_file_path = input('Path to file to be encrypted: ')
        print()
        mes = file_to_message(load_file_path)
        bm = message_to_binary(mes)
        
    if pin != None:
        if pin.isnumeric():
            k = key(int(pin),len(bm))
        else:
            k = key2(pin,len(bm))
    else:
        print()
        pin = input('Encryption Pin: ')
        print()
        if pin.isnumeric():
            k = key(int(pin),len(bm))
        else:
            k = key2(pin,len(bm))
    
    if algorithm == 'CBC':
        eb = encrypt_binary_cipher_block_chaining(bm, k)
    else:
        eb = encrypt_binary_stream_cipher(bm, k)
    
    em = binary_to_message(eb)
    
    if save_file_path != None:
        message_to_file(em,save_file_path)
    else:
        print()
        save_file_path = input('Name and path for encrypted file: ')
        print()
        message_to_file(em,save_file_path)
    

def decrypt_file(load_file_path=None, save_file_path=None, pin=None,algorithm='CBC'):
    if load_file_path != None:
        emes = file_to_message(load_file_path)
        eb = message_to_binary(emes)
    else:
        print()
        load_file_path = input('Path to file to be decrypted: ')
        print()
        emes = file_to_message(load_file_path)
        eb = message_to_binary(emes)
        
    if pin != None:
        if pin.isnumeric():
            k = key(int(pin),len(eb))
        else:
            k = key2(pin,len(eb))
    else:
        print()
        pin = input('Decryption Pin: ')
        print()
        if pin.isnumeric():
            k = key(int(pin),len(eb))
        else:
            k = key2(pin,len(eb))
    
    if algorithm == 'CBC':
        db = decrypt_binary_cipher_block_chaining(eb, k)
    else:
        db = decrypt_binary_stream_cipher(eb, k)
    
    mes = binary_to_message(db)
    if save_file_path != None:
        message_to_file(mes,save_file_path)
    else:
        print()
        save_file_path = input('Name and path for decrypted file: ')
        print()
        message_to_file(mes,save_file_path)


def encrypt_message(message=None, pin=None, algorithm='CBC', save_encrypted_message = False, save_file_path = 'encrypted_message.txt'):
    if message != None:
        bm = message_to_binary(message)
    else:
        print()
        mes = input('Message to be encrypted: ')
        print()
        bm = message_to_binary(mes)
        
    if pin != None:
        if pin.isnumeric():
            k = key(int(pin),len(bm))
        else:
            k = key2(pin,len(bm))
    else:
        print()
        pin = input('Encryption Pin: ')
        print()
        if pin.isnumeric():
            k = key(int(pin),len(bm))
        else:
            k = key2(pin,len(bm))
    
    if algorithm == 'CBC':
        eb = encrypt_binary_cipher_block_chaining(bm, k)
    else:
        eb = encrypt_binary_stream_cipher(bm, k)
    
    em = binary_to_message(eb)
    
    if save_encrypted_message:
        message_to_file(em,save_file_path)
    else:
        print('Encrypted message: \n',em)

def decrypt_message(message=None, pin=None, algorithm='CBC', save_decrypted_message = False, save_file_path = 'decrypted_message.txt'):
    if message != None:
        eb = message_to_binary(message)
    else:
        print()
        message = input('Message to be decrypted: ')
        print()
        eb = message_to_binary(message)
        
    if pin != None:
        if pin.isnumeric():
            k = key(int(pin),len(eb))
        else:
            k = key2(pin,len(eb))
    else:
        print()
        pin = input('Encryption Pin: ')
        print()
        if pin.isnumeric():
            k = key(int(pin),len(eb))
        else:
            k = key2(pin,len(eb))
    
    if algorithm == 'CBC':
        db = decrypt_binary_cipher_block_chaining(eb, k)
    else:
        db = decrypt_binary_stream_cipher(eb, k)
    
    mes = binary_to_message(db)
    
    if save_decrypted_message:
        message_to_file(mes,save_file_path)
    else:
        print('Decrypted message: \n',mes)
    
    
# End.        